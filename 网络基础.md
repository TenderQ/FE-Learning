# 网络基础

## 从输入URL到页面加载的全过程

1. 浏览器的地址栏输入URL并按下回车

2. 浏览器查找当前URL是否存在缓存，并比较缓存是否过期(`cache-control`, `Expires`, `Etag`, `last-modified`)

3. DNS解析URL对应的IP

4. 根据IP建立TCP连接（三次握手）

5. HTTP发起请求

6. 服务器处理请求，浏览器接收HTTP响应

7. 渲染页面，构建DOM树

8. 关闭TCP连接（四次挥手）

详细介绍请跳转[从输入url到页面加载完成发生了什么？——前端角度](https://www.cnblogs.com/daijinxue/p/6640153.html)

## TCP与UDP区别

1. TCP**面向连接**（如打电话要先拨号建立连接）; UDP是**无连接**的，即发送数据之前不需要建立连接
2. TCP提供**可靠**的服务;UDP尽最大努力交付，即**不保证可靠交付**。 TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
3. UDP具有较好的**实时性**，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
4. 每一条TCP连接只能是**点到点**的;UDP支持**一对一，一对多，多对一和多对多**的交互通信
5. TCP对**系统资源要求较多**，UDP对**系统资源要求较少**。

## TCP 为什么是可靠连接

- 通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。
- TCP 报文头里面的序号能使 TCP 的数据按序到达
- 报文头里面的确认序号能保证不丢包，累计确认及超时重传机制
- TCP 拥有流量控制及拥塞控制的机制

## TCP的三次握手及四次挥手

### 三次握手

![三次握手](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=553823905,3270509229&fm=173&app=25&f=JPEG?w=581&h=400&)

1. 连接开始时，连接建立方(Client)发送SYN包，并包含了自己的初始序号a

2. 连接接受方(Server)收到SYN包以后会回复一个SYN包，其中包含了对上一个a包的回应信息ACK，回应的序号为下一个希望收到包的序号，即a＋1，然后还包含了自己的初始序号b

3. 连接建立方(Client)收到回应的SYN包以后，回复一个ACK包做响应，其中包含了下一个希望收到包的序号即b＋1

### 四次挥手

![四次挥手](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2093785618,4182910024&fm=173&app=25&f=JPEG?w=590&h=402)

1. 首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这个FIN）执行被动关闭

2. 当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号

3. 同时TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符。接着这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN

4. 客户必须发回一个确认，并将确认序号设置为收到序号加1。

## 常见状态码

- 1xx：指示信息–表示请求已接收，继续处理

- 2xx：成功–表示请求已被成功接收、理解、接受

- 3xx：重定向–要完成请求必须进行更进一步的操作

  - 301 永久重定向
  - 302 临时重定向
  - 304 请求的网页未修改过

- 4xx：客户端错误–请求有语法错误或请求无法实现

  - 404 请求资源不存在

- 5xx：服务器端错误–服务器未能实现合法的请求

  - 502 网关错误
  - 503 服务器停机维护导致不可访问

## HTTP/1.1 存在的问题

1. TCP 连接数限制

   对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接

2. 线头阻塞 (`Head Of Line Blocking`) 问题

   每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻

3. Header 内容多

   每次请求 Header 不会变化太多，没有相应的压缩传输优化方案

4. 为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制

5. 明文传输不安全

## HTTP/2 的理解

1. 二进制分帧层 (`Binary Framing Layer`)

   帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧

2. 多路复用 (`MultiPlexing`)

   把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。

   流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题

3. 服务端推送 (`Server Push`)

   浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。

   Server-Push 主要是针对资源内联做出的优化，相较于 http/1.1 资源内联的优势:

        客户端可以缓存推送的资源
        客户端可以拒收推送过来的资源
        推送资源可以由不同页面共享
        服务器可以按照优先级推送资源

4. Header 压缩 (`HPACK`算法)

5. 应用层的重置连接

6. 请求优先级设置

   HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题

7. 流量控制

8. HTTP/1 的几种优化可以弃用

   合并文件、内联资源、雪碧图、域名分片对于 HTTP/2 来说是不必要的，使用 http/2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多

9. 更安全的SSL

## HTTPS与HTTP的区别

1. HTTPS的服务器需要到CA申请证书，以证明自己服务器的用途

2. HTTP信息是**明文传输**，HTTPS信息是**密文传输**

3. HTTP与HTTPS的端口不同，一个是**80**端口，一个是**443**端口

可以说HTTP与HTTPS是完全不同的连接方式，HTTPS集合了加密传输，身份认证，更加的安全。

## HTTPS的原理

1. 客户端首先会将自己支持的加密算法，打个包告诉服务器端

2. 服务器端从客户端发来的加密算法中，选出一组加密算法和HASH算法（注，HASH也属于加密），并将自己的身份信息以证书的形式发回给客户端。而证书中包含了网站的地址，加密用的公钥，以及证书的颁发机构等

3. 客户端收到了服务器发来的数据包后，会做这么几件事情：

    1. **验证一下证书是否合法**。一般来说，证书是用来标示一个站点是否合法的标志。如果说该证书由权威的第三方颁发和签名的，则说明证书合法。
    2. 如果证书合法，或者客户端接受和信任了不合法的证书，则客户端就会**随机产生一串序列号，使用服务器发来的公钥进行加密**。这时候，一条返回的消息就基本就绪。
    3. 最后**使用服务器挑选的HASH算法，将刚才的消息使用刚才的随机数进行加密**，生成相应的消息校验值，与刚才的消息一同发还给服务器。

4. 服务器接受到客户端发来的消息后，会做这么几件事情：

    1. **使用私钥解密上面第(2)中公钥加密的消息**，得到客户端产生的随机序列号。
    2. **使用该随机序列号，对该消息进行加密**，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任
    3. 最后，**使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息**，发还给客户端。同时HASH值也带上

5. 客户端收到服务器端的消息后，接着做这么几件事情：

    1. 计算HASH值是否与发回的消息一致
    2. 检查消息是否为握手消息

## 关于缓存Expires、Catch-Control、Last-Modified、Etag的认识

- Expires

  HTTP 1.0时出现，设置缓存的截止时间。`Expires`是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。

- Catch-Control

  HTTP 1.1，设置资源在本地缓存多长时间,使用`Cache-Control: max-age=秒`替代。如果`Cache-Control`与`expires`同时存在，`Cache-Control`生效

  - `max-age=[秒]` 在指定时间内，缓存服务器不再对资源的有效性进行确认
  - `no-cache` 不判断缓存资源是否过期，直接将请求发送给源服务器
  - `no-store` 不可缓存
  - `max-stale(=[秒])` 提示缓存服务器，即使资源过期也接收；或者过期后的指定时间内，客户端也会接收(请求报文私有字段)

- Last-Modified / If-Modified-Since

  `Last-Modified`是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送`If-Modified-Since`字段。服务器用本地`Last-modified`时间与`If-Modified-Since`时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送**304**状态码，让浏览器继续使用缓存。

- Etag / If-None-Match

  Etag用来表示资源的唯一实体标识（哈希字符串）

  当浏览器第一次请求一个url时，服务器端的返回状态码为200，同时HTTP响应头会有一个`Etag`，存放着服务器端生成的一个序列值。

  浏览器第二次请求上次请求过的url时，浏览器会在HTTP请求头添加一个`If-None-Match`的标记，用来询问服务器该文件有没有被修改。

  Etag 主要为了解决 Last-Modified 无法解决的一些问题:

    1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;
    2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，`If-Modified-Since`能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
    3. 某些服务器不能精确的得到文件的最后修改时间；

- 禁止缓存

``` html
<!--禁止浏览器本地缓存 -->
<meta http-equiv="Cache-Control" content="no-cache"/>
<!-- 或者 -->
<meta http-equiv="Cache-Control" content="max-age=0"/>
```

## http请求头和响应头都有哪些内容

- 请求头

  - Accept:浏览器能够处理的内容类型
  - Accept-Charset:浏览器能够显示的字符集
  - Accept-Encoding：浏览器能够处理的压缩编码
  - Accept-Language：浏览器当前设置的语言
  - Connection：浏览器与服务器之间连接的类型（Keep-Alive）
  - Cookie：当前页面设置的任何Cookie
  - Host：发出请求的页面所在的域
  - Referer：发出请求的页面的URL
  - User-Agent：浏览器的用户代理字符串

- 响应头

  - Date：表示消息发送的时间，时间的描述格式由rfc822定义
  - server:服务器名字。
  - Connection：浏览器与服务器之间连接的类型
  - content-type:表示后面的文档属于什么MIME类型
  - Cache-Control：控制HTTP缓存
  - Last-modified: 文件最后修改日期
  - Etag: 文件资源标识
