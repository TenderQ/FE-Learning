# JS面试题

## 'newArray'中有哪些元素

``` js
var array = [];
for (var i = 0; i < 3; i++) {
    // 三个箭头函数体中的每个'i'都指向相同的绑定，
    // 这就是为什么它们在循环结束时返回相同的值'3'。
    array.push(() => i);
}
var newArray = array.map(el => el());
console.log(newArray); // [3, 3, 3]
```

这个问题，是循环结构会给大家带来一种块级作用域的误区，在for的循环的头部使用var声明的变量，就是单个声明的变量绑定（单个存储空间）。在循环过程中，这个var声明的i变量是会随循环变化的。但是在循环中执行的数组push方法，最后实际上是push了i最终循环结束的3这个值。所以最后push进去的全都是3。

> 解决这个问题的一种解决方案是将var换成es6的let，或者使用闭包

``` js
let array = [];
for (var i = 0; i < 3; i++) {
    array[i] = (function(x) {
      return function() {
        return x;
      };
    })(i);
}
const newArray = array.map(el => el());
console.log(newArray); // [0, 1, 2]
```

## 下面这段代码，浏览器控制台上会打印什么

``` js
var a = 10; // 全局作用域，全局变量。a=10
function foo() {
  // 下方var a 的声明将被提升到到函数的顶部。
  console.log(a); // 打印 undefined

  // 实际初始化值20只发生在这里
  var a = 20; // local scope
}
```

使用var关键字声明的变量在JavaScript中会被提升，并在内存中开辟空间，由于没有赋值，无法定义数值类型，所以分配默认值undefined。var声明的变量，真正的数值初始化，是发生在你确定赋值的位置。同时，我们要知道，var声明的变量是函数作用域的，也就是我们需要区分局部变量和全局变量，而let和const是块作用域的。
