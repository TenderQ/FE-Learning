# 网络基础

## 从输入URL到页面加载的全过程

1. 浏览器的地址栏输入URL并按下回车

2. 浏览器查找当前URL是否存在缓存，并比较缓存是否过期(`cache-control`, `Expires`, `Etag`, `last-modified`)

3. DNS解析URL对应的IP

4. 根据IP建立TCP连接（三次握手）

5. HTTP发起请求

6. 服务器处理请求，浏览器接收HTTP响应

7. 渲染页面，构建DOM树

8. 关闭TCP连接（四次挥手）

详细介绍请跳转[从输入url到页面加载完成发生了什么？——前端角度](https://www.cnblogs.com/daijinxue/p/6640153.html)

## TCP的三次握手及四次挥手

### 三次握手

![三次握手](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=553823905,3270509229&fm=173&app=25&f=JPEG?w=581&h=400&)

1. 连接开始时，连接建立方(Client)发送SYN包，并包含了自己的初始序号a

2. 连接接受方(Server)收到SYN包以后会回复一个SYN包，其中包含了对上一个a包的回应信息ACK，回应的序号为下一个希望收到包的序号，即a＋1，然后还包含了自己的初始序号b

3. 连接建立方(Client)收到回应的SYN包以后，回复一个ACK包做响应，其中包含了下一个希望收到包的序号即b＋1

### 四次挥手

![四次挥手](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2093785618,4182910024&fm=173&app=25&f=JPEG?w=590&h=402)

1. 首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这个FIN）执行被动关闭

2. 当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号

3. 同时TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符。接着这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN

4. 客户必须发回一个确认，并将确认序号设置为收到序号加1。

## 常见状态码

- 1xx：指示信息–表示请求已接收，继续处理

- 2xx：成功–表示请求已被成功接收、理解、接受

- 3xx：重定向–要完成请求必须进行更进一步的操作

- 4xx：客户端错误–请求有语法错误或请求无法实现

- 5xx：服务器端错误–服务器未能实现合法的请求

## HTTP/1.1 存在的问题

1. TCP 连接数限制

   对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接

2. 线头阻塞 (`Head Of Line Blocking`) 问题

   每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻

3. Header 内容多

   每次请求 Header 不会变化太多，没有相应的压缩传输优化方案

4. 为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制

5. 明文传输不安全

## HTTP/2 的理解

1. 二进制分帧层 (`Binary Framing Layer`)

   帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧

2. 多路复用 (`MultiPlexing`)

   把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。

   流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题

3. 服务端推送 (`Server Push`)

   浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。

   Server-Push 主要是针对资源内联做出的优化，相较于 http/1.1 资源内联的优势:

        客户端可以缓存推送的资源
        客户端可以拒收推送过来的资源
        推送资源可以由不同页面共享
        服务器可以按照优先级推送资源

4. Header 压缩 (`HPACK`算法)

5. 应用层的重置连接

6. 请求优先级设置

   HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题

7. 流量控制

8. HTTP/1 的几种优化可以弃用

   合并文件、内联资源、雪碧图、域名分片对于 HTTP/2 来说是不必要的，使用 http/2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多

9. 更安全的SSL

## HTTPS与HTTP的区别

1. HTTPS的服务器需要到CA申请证书，以证明自己服务器的用途

2. HTTP信息是**明文传输**，HTTPS信息是**密文传输**

3. HTTP与HTTPS的端口不同，一个是**80**端口，一个是**443**端口

可以说HTTP与HTTPS是完全不同的连接方式，HTTPS集合了加密传输，身份认证，更加的安全。

## HTTPS的原理

1. 客户端首先会将自己支持的加密算法，打个包告诉服务器端

2. 服务器端从客户端发来的加密算法中，选出一组加密算法和HASH算法（注，HASH也属于加密），并将自己的身份信息以证书的形式发回给客户端。而证书中包含了网站的地址，加密用的公钥，以及证书的颁发机构等

3. 客户端收到了服务器发来的数据包后，会做这么几件事情：

    1. **验证一下证书是否合法**。一般来说，证书是用来标示一个站点是否合法的标志。如果说该证书由权威的第三方颁发和签名的，则说明证书合法。
    2. 如果证书合法，或者客户端接受和信任了不合法的证书，则客户端就会**随机产生一串序列号，使用服务器发来的公钥进行加密**。这时候，一条返回的消息就基本就绪。
    3. 最后**使用服务器挑选的HASH算法，将刚才的消息使用刚才的随机数进行加密**，生成相应的消息校验值，与刚才的消息一同发还给服务器。

4. 服务器接受到客户端发来的消息后，会做这么几件事情：

    1. **使用私钥解密上面第(2)中公钥加密的消息**，得到客户端产生的随机序列号。
    2. **使用该随机序列号，对该消息进行加密**，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任
    3. 最后，**使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息**，发还给客户端。同时HASH值也带上

5. 客户端收到服务器端的消息后，接着做这么几件事情：

    1. 计算HASH值是否与发回的消息一致
    2. 检查消息是否为握手消息